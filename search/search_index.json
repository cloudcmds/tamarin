{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tamarin","text":"<p>Tamarin is an embedded scripting language for Go projects.</p> <p>Integrating Tamarin into your Go program or library provides extensibility. You enable users of your application to extend and modify its functionality without recompiling.</p> <p>You may also find that the Tamarin CLI is handy for command line scripting, thanks to the single binary distribution, handy built-in functions, and convenient syntax.</p> <pre><code>[\"welcome\", \"to\", \"tamarin\", \"\ud83d\udc4b\"] | strings.join(\" \")\n</code></pre>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Allow users of your Go program to customize event processing.</li> <li>Add customization hooks to any CLI written in Go.</li> <li>Enable users of your library to write scripts that call methods on your Go structs.</li> <li>Add dynamic behaviors to a Go web server to customize initialization or   request handling.</li> <li>Extend game engines with a scripting interface.</li> <li>Sandbox execution of user scripts in a SaaS application.</li> </ul>"},{"location":"#why-choose-tamarin","title":"Why Choose Tamarin?","text":"<p>There are already some really handy embedded scripting languages for Go (visit awesome-go). Tamarin is different in a few important ways and you can consider whether this makes it a good match for your project:</p> <ul> <li>General purpose, but with built-in capabilities for HTTP requests and more.</li> <li>Familiar syntax for Go and Python developers.</li> <li>Exposes a portion of the Go standard library to scripts.</li> <li>Expressive and intuitive list, map, string, set, and time data types.</li> <li>Pipe expressions to easily express processing pipelines.</li> <li>First-class error handling mechanisms.</li> <li>Easily customizable built-in functions.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Head over to Quick Start for information on how to start using Tamarin as a CLI or a library. There are also a variety of examples on the Github that demonstrate using Tamarin as a library.</p>"},{"location":"Features/","title":"Tamarin Language Features","text":"<p>Here is an overview of Tamarin Language Features. This is not comprehensive.</p>"},{"location":"Features/#print","title":"Print","text":"<p>Print to stdout:</p> <pre><code>print(\"Hello gophers!\")\n</code></pre> <p>Print any number of variables:</p> <pre><code>print(\"x:\", x, \"y:\", y)\n</code></pre> <p>Equivalent to <code>fmt.Println</code>.</p>"},{"location":"Features/#assignment-statements","title":"Assignment Statements","text":"<p>Both <code>var</code> and <code>const</code> statements are supported:</p> <pre><code>var x = 42\nconst y = \"this is a constant\"\n</code></pre> <p>Using the <code>:=</code> operator instead of <code>var</code> is encouraged:</p> <pre><code>x := 42\n</code></pre>"},{"location":"Features/#dynamic-typing","title":"Dynamic Typing","text":"<p>Variables may change type, similar to Python.</p> <pre><code>x := 42\nx = \"now a string\"\nprint(x)\n</code></pre>"},{"location":"Features/#optional-semicolons","title":"Optional Semicolons","text":"<p>Semicolons are optional, so statements are ended by newlines if semicolons are not present.</p> <pre><code>foo := \"bar\"; baz := \"qux\"\n</code></pre>"},{"location":"Features/#comments","title":"Comments","text":"<p>Lines are commented using <code>//</code>.</p> <pre><code>// This line is commented out\n</code></pre> <p>Block comments are defined using <code>/*</code> and <code>*/</code>.</p>"},{"location":"Features/#integers","title":"Integers","text":"<p>Integers are represented by Go's <code>int64</code> type internally. Numeric operations that involve a mix of int and float inputs generally produce a float output. Integers are automaticaly converted to floats in these situations.</p> <pre><code>&gt;&gt;&gt; 1 + 3.3\n4.3\n&gt;&gt;&gt; type(1)\nint\n</code></pre>"},{"location":"Features/#floats","title":"Floats","text":"<p>Floating point numbers use Go's <code>float64</code> type internally.</p> <pre><code>&gt;&gt;&gt; math.max([1.0, 2.0])\n2.0\n&gt;&gt;&gt; type(2.0)\nfloat\n</code></pre>"},{"location":"Features/#strings","title":"Strings","text":"<p>Strings come in three varieties. The standard string uses double quotes and behaves very similarly to Go's string. Single quoted strings are similar, but have the additional feature of supporting string templating similar to Python's f-strings. Finally, raw strings are defined using backticks. Use raw strings when you want to include backslashes, single or double quotes, or newlines in your string.</p> <pre><code>salutation := \"hello there\"        // double-quoted string\ncount_str := 'the count is {1+1}'  // single-quoted string\nraw_str := `\\t\\r\\n`                // raw string\n</code></pre>"},{"location":"Features/#functions","title":"Functions","text":"<p>Functions are defined using the <code>func</code> keyword. They may be passed around as values. The <code>return</code> keyword is optional. If not present, the value of the last statement or expression in the block is understood to be the return value. Expressions that do not evaluate to a value will result in an <code>*object.Nil</code> being returned.</p> <pre><code>func addOne(x) {\nx + 1\n}\n// This way of defining a function is equivalent to the above\nconst subOne = func(x) {\nreturn x - 1\n}\naddOne(100)\nsubOne(100)\n</code></pre> <p>Default parameter values are supported:</p> <pre><code>func increment(value, amount=1) {\nreturn value + amount\n}\nprint(increment(100)) // 101\n</code></pre>"},{"location":"Features/#conditionals","title":"Conditionals","text":"<p>Go style if-else statements are supported.</p> <pre><code>name := \"ben\"\nif name == \"noa\" {\nprint(\"the name is noa\")\n} else {\nprint(\"the name is something else\")\n}\n</code></pre>"},{"location":"Features/#switch-statements","title":"Switch Statements","text":"<p>Go style switch statements are supported.</p> <pre><code>name := \"ben\"\nswitch name {\ncase \"ben\":\nprint(\"matched ben\")\ncase \"noa\":\nprint(\"matched noa\")\ndefault:\nprint(\"default\")\n}\n</code></pre>"},{"location":"Features/#loops","title":"Loops","text":"<p>Four forms of for loops are accepted. The <code>break</code> and <code>continue</code> keywords may be used to control looping as you'd expect from other languages.</p> <p>This form includes init, condition, and post statements:</p> <pre><code>for i := 0; i &lt; 10; i++ {\nprint(i)\n}\n</code></pre> <p>This simple form will loop until a <code>break</code> is executed:</p> <pre><code>for {\nif a &gt; b {\nbreak\n}\n}\n</code></pre> <p>This form checks a condition before evaluating the loop body:</p> <pre><code>for a &lt; b {\n}\n</code></pre> <p>You may also use the <code>range</code> keyword to iterate through a container:</p> <pre><code>mylist := [1, 2, 3]\nfor index, value := range mylist { ... }\n</code></pre>"},{"location":"Features/#iterators","title":"Iterators","text":"<p>You can step through items in any container using an iterator. You can create an iterator using the <code>iter</code> builtin function or by using the <code>range</code> keyword.</p> <pre><code>&gt;&gt;&gt; iter({1,2,3})\nset_iter({1, 2, 3})\n</code></pre> <pre><code>&gt;&gt;&gt; range {one: 1, two: 2}\nmap_iter({\"one\": 1, \"two\": 2})\n</code></pre> <p>Iterators offer a <code>next</code> method to retrieve the next entry in the sequence. Each entry is returned as an <code>iter_entry</code> object, which has <code>key</code> and <code>value</code> attributes. When the iterator is exhausted, <code>nil</code> is returned instead.</p> <p>For loops work with these iterators natively, and automatically assign the key and value to the loop variables. But you can use iterators directly as well.</p> <pre><code>&gt;&gt;&gt; entry := range {foo: \"bar\"}.next()\niter_entry(\"foo\", \"bar\")\n&gt;&gt;&gt; entry.key\n\"foo\"\n&gt;&gt;&gt; entry.value\n\"bar\"\n</code></pre>"},{"location":"Features/#the-in-keyword","title":"The \"in\" keyword","text":"<p>Check if an item exists is a container using the <code>in</code> keyword:</p> <pre><code>&gt;&gt;&gt; 42 in [40, 41, 42]\ntrue\n&gt;&gt;&gt; 3 in {2,3,4}\ntrue\n&gt;&gt;&gt; \"foo\" in {foo: \"bar\"}\ntrue\n&gt;&gt;&gt; \"foo\" in \"bar foo baz\"\ntrue\n</code></pre>"},{"location":"Features/#operations-that-may-fail","title":"Operations that may fail","text":"<p><code>Result</code> objects wrap <code>Ok</code> and <code>Err</code> values for operations that may fail.</p> <pre><code>obj := json.unmarshal(\"true\")\nobj.unwrap() // returns true\nfailed := json.unmarshal(\"/not-valid/\")\nfailed.is_err() // returns true\nfailed.unwrap() // raises error that stops execution\n</code></pre>"},{"location":"Features/#pipe-expressions","title":"Pipe Expressions","text":"<p>These execute a series of function calls, passing the result from one stage in as the first argument to the next.</p> <p>This pipe expression evalutes to the string <code>\"HELLO\"</code>.</p> <pre><code>\"hello\" | strings.to_upper\n</code></pre>"},{"location":"Features/#list-methods","title":"List Methods","text":"<p>Lists offer <code>map</code> and <code>filter</code> methods:</p> <pre><code>list := [1, 2, 3, 4].filter(func(x) { x &lt; 3 })\nlist = list.map(func(x) { x \\* x })\n// list is now [1, 4]\n</code></pre>"},{"location":"Features/#builtins","title":"Builtins","text":"<pre><code>all(arr)            // true if all items in arr are truthy\nany(arr)            // true if any item in arr is truthy\nassert(obj, msg)    // raises an error if obj is falsy\nbool(obj)           // evaluates an object's truthiness\ncall(fn, ...)       // call the given function (can be useful in pipe expressions)\nchr()               // convert an integer to its corresponding unicode rune\ndelete(map, key)    // delete an item from the map\nerr(message)        // create a Result error object\nerror(message)      // raise an error\nfloat(s)            // convert a string to a float\ngetattr(obj, name)  // get the object's attribute with the given name\nint(s)              // convert a string to an int\niter(obj)           // returns an iterator for the given container\nkeys(map)           // returns an array of keys in the given map\nlen(s)              // returns the size of the string, list, map, or set\nlist(obj)           // create a new list populated with items from the given iterable\nok(result)          // create a Result object containing the given object\nord()               // convert a unicode character to its integer value\nprint(...)          // equivalent to fmt.Println\nprintf(...)         // equivalent to fmt.Printf\nreversed(arr)       // returns a reversed version of the given array\nset(obj)            // create a new set populated with items from the given iterable\nsorted(obj)         // return a sorted list of items from a container\nsprintf(msg, ...)   // equivalent to fmt.Sprintf\nstring(obj)         // convert an object to its string representation\ntry(expr, fallback) // evaluate expr and return fallback if an error occurs\ntype(x)             // returns the string type name of x\nunwrap_or(obj)      // unwraps but returns the provided obj if the Result is an Error\nunwrap(result)      // unwraps the ok value from the Result if allowed\n</code></pre>"},{"location":"Features/#types","title":"Types","text":"<p>A variety of built-in types are available.</p> <pre><code>101         // int\n1.1         // float\n\"1\"         // string\n[1,2,3]     // list\n{\"key\":2}   // map\n{1,2}       // set\nfalse       // bool\nnil         // nil\nfunc() {}   // function\ntime.now()  // time\niter([1])   // list_iter\niter(set()) // set_iter\niter({})    // map_iter\niter(\"1\")   // string_iter\n</code></pre> <p>There are also <code>HttpResponse</code> and <code>DatabaseConnection</code> types in progress.</p>"},{"location":"Features/#standard-library","title":"Standard Library","text":"<p>Documentation for this is a work in progress. For now, browse the modules here.</p>"},{"location":"Features/#proxying-calls-to-go-objects","title":"Proxying Calls to Go Objects","text":"<p>You can expose arbitrary Go objects to Tamarin code in order to enable method calls on those objects. This allows you to expose existing structs in your application as Tamarin objects that scripts can be written against. Tamarin automatically discovers public methods on your Go types and converts inputs and outputs for primitive types and for structs that you register.</p> <p>Input and output values are type-converted automatically, for a variety of types. Go structs are mapped to Tamarin map objects. Go <code>context.Context</code> and <code>error</code> values are handled automatically.</p> proxy_service.go<pre><code>    // Create a registry that tracks proxied Go types and their attributes\nregistry, err := object.NewTypeRegistry()\nif err != nil {\nreturn err\n}\n// This is the Go service we will expose in Tamarin\nsvc := &amp;MyService{}\n// Wrap the service in a Tamarin Proxy\nproxy, err := object.NewProxy(registry, svc)\nif err != nil {\nreturn err\n}\n// Add the proxy to a Tamarin execution scope\ns := scope.New(scope.Opts{})\ns.Declare(\"svc\", proxy, true)\n// Execute Tamarin code against that scope. By doing this, the Tamarin\n// code can call public methods on `svc` and retrieve its public fields.\nresult, err := exec.Execute(ctx, exec.Opts{\nInput: string(scriptSourceCode),\nScope: s,\n})\n</code></pre> <p>See example-proxy for a complete example.</p>"},{"location":"built-ins/","title":"Built-in Functions","text":"<p>Tamarin includes this set of default built-in functions. The set of available built-ins is easily customizable, depending on the goals for your project.</p>"},{"location":"built-ins/#allcontainer","title":"all(container)","text":"<p>Returns <code>true</code> if all entries in the given container are \"truthy\".</p> <pre><code>&gt;&gt;&gt; all([true, 1, \"ok\"])\ntrue\n&gt;&gt;&gt; all([true, 0, \"ok\"])\nfalse\n</code></pre>"},{"location":"built-ins/#anycontainer","title":"any(container)","text":"<p>Returns <code>true</code> if any of the entries in the given container are \"truthy\".</p> <pre><code>&gt;&gt;&gt; any([false, 0, \"ok\"])\ntrue\n&gt;&gt;&gt; any([false, 0, \"\"])\nfalse\n</code></pre>"},{"location":"built-ins/#assertx-message","title":"assert(x, message)","text":"<p>Generates an error if <code>x</code> is \"falsy\". If a message is provided, it is used as the assertion error message.</p> <pre><code>&gt;&gt;&gt; assert(1 == 1, \"check failed\")\n&gt;&gt;&gt; assert(1 == 2, \"check failed\")\ncheck failed\n</code></pre>"},{"location":"built-ins/#boolobject","title":"bool(object)","text":"<p>Returns <code>true</code> or <code>false</code> depending on whether the object is considered \"truthy\". Container types including lists, maps, sets, and strings evaluate to <code>false</code> when empty and <code>true</code> otherwise.</p> <pre><code>&gt;&gt;&gt; bool(1)\ntrue\n&gt;&gt;&gt; bool(0)\nfalse\n&gt;&gt;&gt; bool([1])\ntrue\n&gt;&gt;&gt; bool([])\nfalse\n</code></pre>"},{"location":"built-ins/#callfunction-any","title":"call(function, ...any)","text":"<p>Calls the function with given arguments. This is primarily useful in pipe expressions when a function is being passed through the pipe as a variable.</p> <pre><code>&gt;&gt;&gt; func inc(x) { x + 1 }\n&gt;&gt;&gt; call(inc, 99)\n100\n&gt;&gt;&gt; inc | call(41)\n42\n</code></pre>"},{"location":"built-ins/#chrint","title":"chr(int)","text":"<p>Converts an Int to the corresponding unicode rune, which is returned as a String. The <code>ord</code> built-in performs the inverse transformation.</p> <pre><code>&gt;&gt;&gt; chr(8364)\n\"\u20ac\"\n&gt;&gt;&gt; chr(97)\n\"a\"\n</code></pre>"},{"location":"built-ins/#deletemap-key","title":"delete(map, key)","text":"<p>Deletes the item with the specified key from the map. This operation has no effect if the key is not present in the map.</p> <pre><code>&gt;&gt;&gt; m := {one: 1, two: 2}\n{\"one\": 1, \"two\": 2}\n&gt;&gt;&gt; delete(m, \"one\")\n{\"two\": 2}\n&gt;&gt;&gt; delete(m, \"foo\")\n{\"two\": 2}\n</code></pre>"},{"location":"built-ins/#errmessage","title":"err(message)","text":"<p>Returns a new Result object containing the given error message. Results may contain an <code>ok</code> value or an <code>err</code> value, and this built-in is used to construct the latter. This is similar in some ways to Rust's result type.</p> <pre><code>&gt;&gt;&gt; err(\"failed operation\")\nerr(\"failed operation\")\n</code></pre>"},{"location":"built-ins/#errormessage","title":"error(message)","text":"<p>Generates an Error containing the given message. Errors in Tamarin stop evaluation when they are generated, unless a <code>try</code> call is used to stop error propagation.</p> <pre><code>&gt;&gt;&gt; error(\"kaboom\")\nkaboom\n</code></pre>"},{"location":"built-ins/#floatobject","title":"float(object)","text":"<p>Converts a String or Int object to a Float. An error is generated if the operation fails.</p> <pre><code>&gt;&gt;&gt; float(\"4.4\")\n4.4\n</code></pre>"},{"location":"built-ins/#getattrobject-name-default","title":"getattr(object, name, default)","text":"<p>Returns the named attribute from the object, or the default value if the attribute does not exist. The returned attribute is always a Tamarin object, which may be a function. This is similar to getattr in Python.</p> <pre><code>&gt;&gt;&gt; l := [1,2,3]\n[1, 2, 3]\n&gt;&gt;&gt; append := getattr(l, \"append\")\nbuiltin(list.append)\n&gt;&gt;&gt; append(4)\n[1, 2, 3, 4]\n&gt;&gt;&gt; getattr(l, \"unknown\", \"that doesn't exist\")\n\"that doesn't exist\"\n</code></pre>"},{"location":"built-ins/#intobject","title":"int(object)","text":"<p>Converts a String or Float to an Int. An error is generated if the operation fails.</p> <pre><code>&gt;&gt;&gt; int(4.4)\n4\n&gt;&gt;&gt; int(\"123\")\n123\n</code></pre>"},{"location":"built-ins/#itercontainer","title":"iter(container)","text":"<p>Returns an iterator for the given container object. This can be used to iterate through items in a for loop or interacted with more directly. The returned iterator has a <code>next()</code> method that will return <code>iter_entry</code> objects.</p> <pre><code>&gt;&gt;&gt; s := {\"a\", \"b\", \"c\"}\n{\"a\", \"b\", \"c\"}\n&gt;&gt;&gt; iterator := iter(s)\nset_iter({\"a\", \"b\", \"c\"})\n&gt;&gt;&gt; iterator.next().key\n\"a\"\n</code></pre>"},{"location":"built-ins/#keyscontainer","title":"keys(container)","text":"<p>Returns a list of all keys for items in the given map or list container.</p> <pre><code>&gt;&gt;&gt; m := {one: 1, two: 2}\n{\"one\": 1, \"two\": 2}\n&gt;&gt;&gt; keys(m)\n[\"one\", \"two\"]\n</code></pre>"},{"location":"built-ins/#lencontainer","title":"len(container)","text":"<p>Returns the size of the string, list, map, or set.</p> <pre><code>&gt;&gt;&gt; len(\"ab\")        // string length\n2\n&gt;&gt;&gt; len([1,2,3])     // list length\n3\n&gt;&gt;&gt; len({foo:\"bar\"}) // map length\n1\n&gt;&gt;&gt; len({1,2,3,4})   // set length\n4\n</code></pre>"},{"location":"built-ins/#listcontainer","title":"list(container)","text":"<p>Returns a new list populated with items from the given container. If a list is provided, a shallow copy of the list is returned. It is also commonly used to convert a set to a list.</p> <pre><code>&gt;&gt;&gt; s := {\"a\", \"b\", \"c\"}\n{\"a\", \"b\", \"c\"}\n&gt;&gt;&gt; list(s)\n[\"a\", \"b\", \"c\"]\n</code></pre>"},{"location":"built-ins/#okobject","title":"ok(object)","text":"<p>Returns a new Result containing the given ok value. Results may contain an <code>ok</code> value or an <code>err</code> value, and this built-in is used to construct the former. This is similar in some ways to Rust's result type.</p> <pre><code>&gt;&gt;&gt; result := ok(\"that worked\")\nok(\"that worked\")\n&gt;&gt;&gt; result.is_ok()\ntrue\n&gt;&gt;&gt; result.unwrap()\n\"that worked\"\n</code></pre>"},{"location":"built-ins/#ordstring","title":"ord(string)","text":"<p>Converts a unicode character to the corresponding Int value. The <code>chr</code> built-in performs the inverse transformation. An error is generated if a multi-rune string is provided.</p> <pre><code>&gt;&gt;&gt; ord(\"\u20ac\")\n8364\n&gt;&gt;&gt; ord(\"a\")\n97\n&gt;&gt;&gt; chr(ord(\"\u20ac\"))\n\"\u20ac\"\n</code></pre>"},{"location":"built-ins/#printany","title":"print(...any)","text":"<p>Prints the provided objects to stdout after converting them to their String representations. Spaces are inserted between each object and a trailing newline is output. This is a wrapper around <code>fmt.Println</code> in Go.</p> <pre><code>&gt;&gt;&gt; print(42, \"is the answer\")\n42 is the answer\n</code></pre>"},{"location":"built-ins/#printfstring-any","title":"printf(string, ...any)","text":"<p>Printf wraps <code>fmt.Printf</code> in order to print the formatted string and arguments to stdout. In the Tamarin REPL you will currently not see the <code>printf</code> output unless the string ends in a newline character.</p> <pre><code>&gt;&gt;&gt; printf(\"name: %s age: %d\\n\", \"joe\", 32)\nname: joe age: 32\n</code></pre>"},{"location":"built-ins/#reversedlist","title":"reversed(list)","text":"<p>Returns a new list which is a reversed copy of the provided list.</p> <pre><code>&gt;&gt;&gt; l := [\"a\", \"b\", \"c\"]\n[\"a\", \"b\", \"c\"]\n&gt;&gt;&gt; reversed(l)\n[\"c\", \"b\", \"a\"]\n&gt;&gt;&gt; l\n[\"a\", \"b\", \"c\"]\n</code></pre>"},{"location":"built-ins/#setcontainer","title":"set(container)","text":"<p>Returns a new set containing the items from the given container object.</p> <pre><code>&gt;&gt;&gt; set(\"aabbcc\")\n{\"a\", \"b\", \"c\"}\n&gt;&gt;&gt; set([4,4,5])\n{4, 5}\n&gt;&gt;&gt; set({one:1, two:2})\n{\"one\", \"two\"}\n</code></pre>"},{"location":"built-ins/#sortedcontainer","title":"sorted(container)","text":"<p>Returns a sorted list of items from the given container object.</p> <pre><code>&gt;&gt;&gt; sorted(\"cba\")\n[\"a\", \"b\", \"c\"]\n&gt;&gt;&gt; sorted([10, 3, -5])\n[-5, 3, 10]\n</code></pre>"},{"location":"built-ins/#sprintfstring-any","title":"sprintf(string, ...any)","text":"<p>Wraps <code>fmt.Sprintf</code> to format the string with the provided arguments. Tamarin objects are converted to their corresponding Go types before being passed to <code>fmt.Sprintf</code>.</p> <pre><code>&gt;&gt;&gt; sprintf(\"name: %s age: %d\", \"fred\", 18)\n\"name: fred age: 18\"\n&gt;&gt;&gt; sprintf(\"%v\", [1, \"a\", 3.3])\n\"[1 a 3.3]\"\n</code></pre>"},{"location":"built-ins/#stringobject","title":"string(object)","text":"<p>Returns a string representation of the given Tamarin object.</p> <pre><code>&gt;&gt;&gt; string({one:1, two:2})\n\"{\\\"one\\\": 1, \\\"two\\\": 2}\"\n&gt;&gt;&gt; string(4.4)\n\"4.4\"\n&gt;&gt;&gt; string([1,2,3])\n\"[1, 2, 3]\"\n</code></pre>"},{"location":"built-ins/#tryexpression-fallback","title":"try(expression, fallback)","text":"<p>Evaluates the expression and return the fallback value if an error occurs. This works equally well with Error objects and Results containing an error value.</p> <p>If a function is provided as the fallback value, that function is called when an error occurs with the error message as the first argument. The value returned from the function is used as the return value from the <code>try</code> call.</p> <pre><code>&gt;&gt;&gt; try(\"ok\", \"fallback\")\n\"ok\"\n&gt;&gt;&gt; try(error(\"boom\"), \"that failed\")\n\"that failed\"\n&gt;&gt;&gt; try(error(\"boom\"), error(\"transformed err\"))\ntransformed err\n&gt;&gt;&gt; r := err(\"err result\")\nerr(\"err result\")\n&gt;&gt;&gt; try(r, \"the result contained an error\")\n\"the result contained an error\"\n&gt;&gt;&gt; try(r, func(msg) { 'failure: {msg}' })\n\"failure: err result\"\n</code></pre>"},{"location":"built-ins/#typeobject","title":"type(object)","text":"<p>Returns the type name of the given object as a String.</p> <pre><code>&gt;&gt;&gt; type(1)\n\"int\"\n&gt;&gt;&gt; type(2.2)\n\"float\"\n&gt;&gt;&gt; type(\"hi\")\n\"string\"\n&gt;&gt;&gt; type([])\n\"list\"\n&gt;&gt;&gt; type({})\n\"map\"\n&gt;&gt;&gt; type({1,2,3})\n\"set\"\n&gt;&gt;&gt; type(ok(\"success\"))\n\"result\"\n&gt;&gt;&gt; type(err(\"failed\"))\n\"result\"\n</code></pre>"},{"location":"built-ins/#unwrap_orresult-fallback","title":"unwrap_or(result, fallback)","text":"<p>Returns the wrapped \"ok\" value from the given Result object or the fallback value if the Result contains an Error.</p> <pre><code>&gt;&gt;&gt; unwrap_or(ok(\"success\"), \"fallback\")\n\"success\"\n&gt;&gt;&gt; unwrap_or(err(\"boom\"), \"fallback\")\n\"fallback\"\n</code></pre>"},{"location":"built-ins/#unwrapresult","title":"unwrap(result)","text":"<p>Returns the wrapped \"ok\" value from the given Result object. If the Result contains an Error, an Error is generated instead.</p> <pre><code>&gt;&gt;&gt; unwrap(ok(\"success\"))\n\"success\"\n&gt;&gt;&gt; unwrap(err(\"boom\"))\nresult error: unwrap() called on an error: error(\"boom\")\n</code></pre>"},{"location":"data-types/","title":"Data Types","text":"<p>Tamarin includes a variety of built-in types. The core types are: int, float, bool, error, string, list, map, set, result, function, and time. There are also a handful of iterator types, one for each container type.</p> <p>Container types may hold a heterogeneous mix of types within. There is not currently a way to restrict the types a container may hold.</p> <p>Optional type hints like found in Python or Typescript may be a future addition to Tamarin.</p>"},{"location":"data-types/#quick-reference","title":"Quick Reference","text":"<pre><code>101         // int\n1.1         // float\n\"1\"         // string\n[1,2,3]     // list\n{\"key\":2}   // map\n{1,2}       // set\nfalse       // bool\nnil         // nil\nfunc() {}   // function\ntime.now()  // time\n</code></pre>"},{"location":"data-types/#numerics","title":"Numerics","text":"<p>Int and Float types are the two numeric types in Tamarin. They correspond to boxed <code>int64</code> and <code>float64</code> values in Go. Tamarin automatically converts Ints to Floats in mixed type operations.</p> <p>The standard set of numeric operators are available when working with these types.</p> Operation Result x + y sum of x and y x - y difference of x and y x * y product of x and y -x negation of x x ** y x to the power of y x += y add y to x x -= y subtract y from x x *= y multiply x by y x /= y divide x by y <pre><code>&gt;&gt;&gt; x := 2\n2\n&gt;&gt;&gt; y := 3\n3\n&gt;&gt;&gt; x * y\n6\n&gt;&gt;&gt; x + y\n5\n&gt;&gt;&gt; type(x + y)\n\"int\"\n&gt;&gt;&gt; type(x + float(y))\n\"float\"\n</code></pre> <p>Many math functions are also available in the Tamarin <code>math</code> module.</p>"},{"location":"data-types/#related-built-ins","title":"Related Built-ins","text":""},{"location":"data-types/#floatx","title":"float(x)","text":"<p>Converts a String or Int object to a Float. An error is generated if the operation fails.</p> <pre><code>&gt;&gt;&gt; float(\"4.4\")\n4.4\n</code></pre>"},{"location":"data-types/#intx","title":"int(x)","text":"<p>Converts a String or Float to an Int. An error is generated if the operation fails.</p> <pre><code>&gt;&gt;&gt; int(4.4)\n4\n&gt;&gt;&gt; int(\"123\")\n123\n</code></pre>"},{"location":"data-types/#bool","title":"Bool","text":"<p>The <code>bool</code> type in Tamarin is a simple wrapper of the Go <code>bool</code> type.</p> <p>All underlying object types in Tamarin implement the <code>object.Object</code> interface, which includes <code>IsTruthy()</code> and <code>Equals(other)</code> methods. It's good to keep this in mind since object \"truthiness\" can be leveraged in conditional statements.</p> <pre><code>&gt;&gt;&gt; bool(0)\nfalse\n&gt;&gt;&gt; bool(5)\ntrue\n&gt;&gt;&gt; bool([])\nfalse\n&gt;&gt;&gt; bool([1,2,3])\ntrue\n&gt;&gt;&gt; if 5 { print(\"5 is truthy\") }\n5 is truthy\n&gt;&gt;&gt; 5 == 5.0\ntrue\n&gt;&gt;&gt; [1,2] == [1,2]\ntrue\n&gt;&gt;&gt; [1,2] != [1,2]\nfalse\n&gt;&gt;&gt; false == false\ntrue\n</code></pre>"},{"location":"data-types/#related-built-ins_1","title":"Related Built-ins","text":""},{"location":"data-types/#boolx","title":"bool(x)","text":"<p>Returns <code>true</code> or <code>false</code> according to the given objects \"truthiness\". Container types including lists, maps, sets, and strings evaluate to <code>false</code> when empty and <code>true</code> otherwise. Iterators are truthy when there are more items remaining to iterate over. Objects of other types are generally always considered to be truthy.</p>"},{"location":"data-types/#string","title":"String","text":"<p>Strings in Tamarin are based on the underlying <code>string</code> type in Go. As such, they support unicode and various operations like indexing operate on the underlying runes within the string.</p>"},{"location":"data-types/#quote-types","title":"Quote Types","text":"<p>There are three ways to quote strings in Tamarin source code:</p> <pre><code>'single quotes: supports interpolated {vars}'\n\"double quotes: equivalent to Go strings\"\n`backticks: raw strings that may span multiple lines`\n</code></pre> <p>The single quoted string approach offers string formatting via interpolation, much like f-strings in Python. Arbitrary Tamarin expressions can be embedded within parentheses and resolved during evaluation. In Tamarin, the restriction on these expressions is that they cannot contain curly braces, since those are used to mark the beginning and end of the template expression.</p> <p>An example with simple expressions:</p> <pre><code>&gt;&gt;&gt; name := \"jean\"\n\"jean\"\n&gt;&gt;&gt; age := 30\n30\n&gt;&gt;&gt; '{name} is {age} years old'\n\"jean is 30 years old\"\n</code></pre> <p>Another example:</p> <pre><code>&gt;&gt;&gt; nums := [0, 1, 2, 3]\n[0, 1, 2, 3]\n&gt;&gt;&gt; 'the max is {math.max(nums)} and the length is {len(nums)}'\n\"the max is 3 and the length is 4\"\n</code></pre>"},{"location":"data-types/#container-operations","title":"Container Operations","text":"<p>Strings in Tamarin implement the <code>object.Container</code> interface, which means they support typical container-style operations:</p> <pre><code>&gt;&gt;&gt; s := \"hello\"\n\"hello\"\n&gt;&gt;&gt; s[0]\n\"h\"\n&gt;&gt;&gt; len(s)\n5\n&gt;&gt;&gt; s[1:3]\n\"el\"\n&gt;&gt;&gt; s[1:]\n\"ello\"\n&gt;&gt;&gt; s[:1]\n\"h\"\n&gt;&gt;&gt; iter(s)\nstring_iter(\"hello\")\n&gt;&gt;&gt; iter(s).next()\niter_entry(0, \"h\")\n</code></pre>"},{"location":"data-types/#related-built-ins_2","title":"Related Built-ins","text":""},{"location":"data-types/#chrint","title":"chr(int)","text":"<p>Converts an Int to the corresponding unicode rune, which is returned as a String. The <code>ord</code> built-in performs the inverse transformation.</p>"},{"location":"data-types/#ordstring","title":"ord(string)","text":"<p>Converts a unicode character to the corresponding Int value. The <code>chr</code> built-in performs the inverse transformation. An error is generated if a multi-rune string is provided.</p>"},{"location":"data-types/#sprintfstring-any","title":"sprintf(string, ...any)","text":"<p>Wraps <code>fmt.Sprintf</code> to format the string with the provided arguments. Tamarin objects are converted to their corresponding Go types before being passed to <code>fmt.Sprintf</code>.</p>"},{"location":"data-types/#stringx","title":"string(x)","text":"<p>Returns the string representation of any Tamarin object.</p>"},{"location":"data-types/#methods","title":"Methods","text":""},{"location":"data-types/#stringcontainss","title":"string.contains(s)","text":"<p>Returns a bool that indicates if <code>s</code> is a substring of this string.</p>"},{"location":"data-types/#stringhas_prefixs","title":"string.has_prefix(s)","text":"<p>Checks whether the string begins with the prefix <code>s</code>.</p>"},{"location":"data-types/#stringhas_suffixs","title":"string.has_suffix(s)","text":"<p>Checks whether the string ends with the suffix <code>s</code>.</p>"},{"location":"data-types/#stringcounts","title":"string.count(s)","text":"<p>Returns the number of occurrences of <code>s</code> in this string.</p>"},{"location":"data-types/#stringjoinlist","title":"string.join(list)","text":"<p>Return the joined result of the given list of strings, using this string as the separator.</p>"},{"location":"data-types/#stringsplitseparator","title":"string.split(separator)","text":"<p>Splits this string on all occurrences of the given separator, returning the resulting list of strings.</p>"},{"location":"data-types/#stringfields","title":"string.fields()","text":"<p>Splits this string on whitespace, returning the list of non-whitespace substrings. If this string is only whitespace, an empty list is returned.</p>"},{"location":"data-types/#stringindexs","title":"string.index(s)","text":"<p>Returns the index of the first occurence of <code>s</code> in this string, or <code>-1</code> if <code>s</code> is not present.</p>"},{"location":"data-types/#stringlast_indexs","title":"string.last_index(s)","text":"<p>Returns the index of the last occurence of <code>s</code> in this string, or <code>-1</code> if <code>s</code> is not present.</p>"},{"location":"data-types/#stringreplace_allold-new","title":"string.replace_all(old, new)","text":"<p>Returns a copy of this string with all occurrences of <code>old</code> replaced by <code>new</code>.</p>"},{"location":"data-types/#stringto_lower","title":"string.to_lower()","text":"<p>Returns a copy of this string that is transformed to all lowercase.</p>"},{"location":"data-types/#stringto_upper","title":"string.to_upper()","text":"<p>Returns a copy of this string that is transformed to all uppercase.</p>"},{"location":"data-types/#stringtrimcutset","title":"string.trim(cutset)","text":"<p>Returns a copy of this string with all leading and trailing characters contained in <code>cutset</code> removed.</p>"},{"location":"data-types/#stringtrim_prefixprefix","title":"string.trim_prefix(prefix)","text":"<p>Returns a copy of this string without the given prefix. This is a no-op if this string doesn't start with <code>prefix</code>.</p>"},{"location":"data-types/#stringtrim_space","title":"string.trim_space()","text":"<p>Returns a copy of this string without the leading and trailing whitespace.</p>"},{"location":"data-types/#stringtrim_suffixsuffix","title":"string.trim_suffix(suffix)","text":"<p>Returns a copy of this string without the given suffix. This is a no-op if this string doesn't end with <code>suffix</code>.</p>"},{"location":"data-types/#list","title":"List","text":"<p>Lists in Tamarin behave very similarly to lists in Python. Methods and indexing on lists are the primary way to interact with these objects. A list can store objects of any types, including a mix of types in one list.</p> <pre><code>&gt;&gt;&gt; l := [\"a\", 1, 2]\n[\"a\", 1, 2]\n&gt;&gt;&gt; l.append(\"tail\")\n[\"a\", 1, 2, \"tail\"]\n</code></pre>"},{"location":"data-types/#container-operations_1","title":"Container Operations","text":"<pre><code>&gt;&gt;&gt; l := [\"a\", \"b\", \"c\"]\n[\"a\", \"b\", \"c\"]\n&gt;&gt;&gt; len(l)\n3\n&gt;&gt;&gt; \"c\" in l\ntrue\n&gt;&gt;&gt; \"d\" in l\nfalse\n&gt;&gt;&gt; l[2]\n\"c\"\n&gt;&gt;&gt; l[2] = \"d\"\n&gt;&gt;&gt; l\n[\"a\", \"b\", \"d\"]\n&gt;&gt;&gt; l[1:]\n[\"b\", \"d\"]\n&gt;&gt;&gt; l[:1]\n[\"a\"]\n</code></pre>"},{"location":"data-types/#related-built-ins_3","title":"Related Built-ins","text":""},{"location":"data-types/#listcontainer","title":"list(container)","text":"<p>Returns a new list populated with items from the given container. If a list is provided, a shallow copy of the list is returned. It is also commonly used to convert a set to a list.</p> <pre><code>&gt;&gt;&gt; s := {\"a\", \"b\", \"c\"}\n{\"a\", \"b\", \"c\"}\n&gt;&gt;&gt; list(s)\n[\"a\", \"b\", \"c\"]\n</code></pre>"},{"location":"data-types/#methods_1","title":"Methods","text":""},{"location":"data-types/#listappendx","title":"list.append(x)","text":"<p>Adds x to the end of the list.</p>"},{"location":"data-types/#listclear","title":"list.clear()","text":"<p>Empties all items from the list.</p>"},{"location":"data-types/#listcopy","title":"list.copy()","text":"<p>Returns a shallow copy of the list.</p>"},{"location":"data-types/#listcountx","title":"list.count(x)","text":"<p>Returns a count of how many times x is found in the list.</p>"},{"location":"data-types/#listextendx","title":"list.extend(x)","text":"<p>Adds all items contained in x to the end of the list.</p>"},{"location":"data-types/#listindexx","title":"list.index(x)","text":"<p>Returns the first index of x in the list, or -1 if not found.</p>"},{"location":"data-types/#listinsertindex-x","title":"list.insert(index, x)","text":"<p>Inserts x into the list at the specified index.</p>"},{"location":"data-types/#listpopindex","title":"list.pop(index)","text":"<p>Removes the item at the given index from the list.</p>"},{"location":"data-types/#listremovex","title":"list.remove(x)","text":"<p>Removes the first occurence of x in the list.</p>"},{"location":"data-types/#listreverse","title":"list.reverse()","text":"<p>Reverses the list in place.</p>"},{"location":"data-types/#listsort","title":"list.sort()","text":"<p>Sorts the list in place.</p>"},{"location":"data-types/#listmapfunc","title":"list.map(func)","text":"<p>Returns a transformed list, in which the given function is applied to each list item.</p>"},{"location":"data-types/#listfilterfunc","title":"list.filter(func)","text":"<p>Returns a transformed list, in which the given function returns true for items that should be added to the output list.</p>"},{"location":"data-types/#listeachfunc","title":"list.each(func)","text":"<p>Calls the supplied function once with each item in the list.</p>"},{"location":"data-types/#map","title":"Map","text":"<p>Maps associate keys with values and provide fast lookups by key. Tamarin maps use underlying Go maps of type <code>map[string]interface{}</code>. This means Tamarin maps always operate with string keys, which provides equivalence with JSON.</p> <pre><code>&gt;&gt;&gt; m := {one: 1, two: 2}\n{\"one\": 1, \"two\": 2}\n&gt;&gt;&gt; m[\"three\"] = 3\n&gt;&gt;&gt; m\n{\"one\": 1, \"three\": 3, \"two\": 2}\n</code></pre>"},{"location":"data-types/#container-operations_2","title":"Container Operations","text":"<pre><code>&gt;&gt;&gt; m := {\"name\": \"sean\", \"age\": 27}\n{\"age\": 27, \"name\": \"sean\"}\n&gt;&gt;&gt; len(m)\n2\n&gt;&gt;&gt; \"age\" in m\ntrue\n&gt;&gt;&gt; m[\"age\"]\n27\n&gt;&gt;&gt; m[\"age\"] = 28\n&gt;&gt;&gt; m\n{\"age\": 28, \"name\": \"sean\"}\n&gt;&gt;&gt; m.keys()\n[\"age\", \"name\"]\n</code></pre>"},{"location":"data-types/#related-built-ins_4","title":"Related Built-ins","text":""},{"location":"data-types/#deletemap-key","title":"delete(map, key)","text":"<p>Deletes the item with the specified key from the map. This operation has no effect if the key is not present in the map.</p>"},{"location":"data-types/#mapcontainer","title":"map(container)","text":"<p>Returns a new map with the contents of the given container. Generally, containers are transformed into the map by creating an iterator for the given container and the key and value for each iterator entry are added to the map. As a special case, if the container is a list then it is expected to be a nested list of key-value pairs, e.g. <code>[[\"key1\", \"val1\"]]</code>. Any non-string keys that are encountered are automatically converted to their string representation.</p> <pre><code>&gt;&gt;&gt; map({\"a\", \"b\", \"c\"})\n{\"a\": true, \"b\": true, \"c\": true}\n&gt;&gt;&gt; map(\"abc\")\n{\"0\": \"a\", \"1\": \"b\", \"2\": \"c\"}\n&gt;&gt;&gt; map([[\"name\", \"joe\"], [\"age\", 18]])\n{\"age\": 18, \"name\": \"joe\"}\n</code></pre>"},{"location":"data-types/#methods_2","title":"Methods","text":""},{"location":"data-types/#mapclear","title":"map.clear()","text":"<p>Removes all items from the map.</p>"},{"location":"data-types/#mapcopy","title":"map.copy()","text":"<p>Returns a shallow copy of the map, containing the same keys and values.</p>"},{"location":"data-types/#mapgetkey-defaultnil","title":"map.get(key, default=nil)","text":"<p>Returns the value associated with the given key, if it exists in the map. If the key is not in the map, the given default value is returned.</p>"},{"location":"data-types/#mapitems","title":"map.items()","text":"<p>Returns a list of [key, value] pairs containing the items from the map.</p>"},{"location":"data-types/#mapkeys","title":"map.keys()","text":"<p>Returns a sorted list of keys contained in the map.</p>"},{"location":"data-types/#mappopkey-defaultnil","title":"map.pop(key, default=nil)","text":"<p>Returns the value associated with the given key and then removes it from the map. If the key is not in the map, the given default value is returned instead.</p>"},{"location":"data-types/#mapsetdefaultkey-default","title":"map.setdefault(key, default)","text":"<p>Sets the key to the given default value if the key is not already in the map. If the key already is in the map, do nothing. Returns the value associated with the key after the set action.</p>"},{"location":"data-types/#mapupdateother","title":"map.update(other)","text":"<p>Updates this map with the key-value pairs contained in the provided map, overwriting any items with matching keys already in this map.</p>"},{"location":"data-types/#mapvalues","title":"map.values()","text":"<p>Returns a sorted list of values contained in the map.</p>"},{"location":"data-types/#set","title":"Set","text":"<p>Sets represent an unordered collection of unique objects. Only hashable objects can be added to sets, which includes bool, int, float, nil, and string. It is not possible to add a list or map to a set, since they are not hashable.</p>"},{"location":"data-types/#container-operations_3","title":"Container Operations","text":"<pre><code>&gt;&gt;&gt; s := {1, 2, 3}\n{1, 2, 3}\n&gt;&gt;&gt; 3 in s\ntrue\n&gt;&gt;&gt; 4 in s\nfalse\n&gt;&gt;&gt; s[3]\ntrue\n&gt;&gt;&gt; s[4]\nfalse\n&gt;&gt;&gt; delete(s, 3)\n&gt;&gt;&gt; s\n{1, 2}\n</code></pre>"},{"location":"data-types/#related-built-ins_5","title":"Related Built-ins","text":""},{"location":"data-types/#deleteset-key","title":"delete(set, key)","text":"<p>Deletes the given key from the set. This is a no-op if the key is not present in the set.</p>"},{"location":"data-types/#setcontainer","title":"set(container)","text":"<p>Returns a new set that is populated with the contents of the given container. The loading behavior for each provided type is as follows:</p> <ul> <li>Given a list, the values within are added to the set.</li> <li>Given a string, the characters within are added to the set.</li> <li>Given a map, the keys within are added to the set.</li> </ul> <pre><code>&gt;&gt;&gt; set([1, 2, 3, 3])\n{1, 2, 3}\n&gt;&gt;&gt; set(\"abc\")\n{\"a\", \"b\", \"c\"}\n&gt;&gt;&gt; set({one: 1, two: 2})\n{\"one\", \"two\"}\n</code></pre>"},{"location":"data-types/#methods_3","title":"Methods","text":""},{"location":"data-types/#setaddx","title":"set.add(x)","text":"<p>Add <code>x</code> to the set. If <code>x</code> is not hashable, an error is generated.</p>"},{"location":"data-types/#setclear","title":"set.clear()","text":"<p>Empties all items from the set.</p>"},{"location":"data-types/#setremovex","title":"set.remove(x)","text":"<p>Remove <code>x</code> from the set. This is a no-op if <code>x</code> is not in the set.</p>"},{"location":"data-types/#setunionother","title":"set.union(other)","text":"<p>Returns a new set which contains the union of all items from this set and the other set.</p>"},{"location":"data-types/#setintersectionother","title":"set.intersection(other)","text":"<p>Returns a new set containing items that are present in both this set and the other set.</p>"},{"location":"error-handling/","title":"Error Handling","text":"<p>There are two concepts used in Tamarin for dealing with situations where something goes wrong: errors and results. A Tamarin object type is used for each of these, <code>object.Error</code> and <code>object.Result</code>. There are various built-in functions and methods used to interact with these as values to design an error resilient application.</p> <p>In short, when an error object is generated, the Tamarin interpreter recognizes the error, evaluation of the code stops, and the error is returned. This means that, by default, a Tamarin program halts on an error.</p> <p>Results are objects that may contain an ok value or an err value. These are returned from operations that have common error conditions, such as I/O operations that may fail due to network problems or similar. These result objects offer methods to test if the result is ok or err and then the developer can decide how the application should handle each of those cases.</p> <p>The built-in function <code>try</code> can be used to work with both errors and results. It allows the developer to return a fallback value when an expression evaluates to an error or an err result.</p>"},{"location":"error-handling/#errors","title":"Errors","text":"<p>Generate an error intentionally using the <code>error</code> built-in function. This stops evaluation of the Tamarin program immediately:</p> <pre><code>&gt;&gt;&gt; error(\"kaboom\")\nkaboom\n</code></pre> <p>Wrap an operation with <code>try</code> to prevent an error from propagating:</p> <pre><code>&gt;&gt;&gt; try(error(\"kaboom\"), \"that failed\")\n\"that failed\"\n</code></pre>"},{"location":"error-handling/#results","title":"Results","text":"<p>Create a result containing an error message using the <code>err</code> built-in function. This result is treated as any other value in Tamarin:</p> <pre><code>&gt;&gt;&gt; e := err(\"io problem\")\nerr(\"io problem\")\n&gt;&gt;&gt; type(e)\n\"result\"\n&gt;&gt;&gt; e.is_err()\ntrue\n&gt;&gt;&gt; e.err_msg()\n\"io problem\"\n</code></pre> <p>Like with errors, the <code>try</code> function works with results:</p> <pre><code>&gt;&gt;&gt; try(err(\"io problem\"), \"fallback value\")\n\"fallback value\"\n</code></pre> <p>Successful results are instead created with the <code>ok</code> built-in function:</p> <pre><code>&gt;&gt;&gt; res := ok(\"result-value\")\nok(\"result-value\")\n&gt;&gt;&gt; res.unwrap()\n\"result-value\"\n&gt;&gt;&gt; res.is_err()\nfalse\n&gt;&gt;&gt; res.is_ok()\ntrue\n</code></pre> <p>The <code>try</code> function returns ok results as-is:</p> <pre><code>&gt;&gt;&gt; res := ok(\"result-value\")\nok(\"result-value\")\n&gt;&gt;&gt; try(res, \"fallback value\")\n\"result-value\"\n</code></pre>"},{"location":"error-handling/#proxying","title":"Proxying","text":"<p>Results containing an ok value proxy to the wrapped value. This is a convenience for scripting situations to avoid needing to explicitly unwrap the result. If this is attempted with an err result, an error is generated that stops execution.</p> <p>This example shows how the result proxies to the <code>map.keys</code> method:</p> <pre><code>&gt;&gt;&gt; res := ok({foo: \"bar\"})\nok({\"foo\": \"bar\"})\n&gt;&gt;&gt; res.keys()\n[\"foo\"]\n&gt;&gt;&gt; m := res.unwrap()\n{\"foo\": \"bar\"}\n&gt;&gt;&gt; m.keys()\n[\"foo\"]\n</code></pre>"},{"location":"error-handling/#try","title":"Try","text":"<p>A fallback function can be provided as the second argument to <code>try</code>:</p> <pre><code>&gt;&gt;&gt; e := err(\"nope\")\nerr(\"nope\")\n&gt;&gt;&gt; try(e, func(msg) { print('operation failed: {msg}') })\noperation failed: nope\n</code></pre>"},{"location":"error-handling/#examples","title":"Examples","text":"<p>The JSON module is designed to return result values for operations that may fail:</p> <pre><code>&gt;&gt;&gt; json.unmarshal(\"true\")\nok(true)\n&gt;&gt;&gt; json.unmarshal(\"invalid-json\")\nerr(\"value error: json.unmarshal failed with: invalid character 'i' looking for beginning of value\")\n</code></pre>"},{"location":"how-it-works/","title":"How It Works","text":"<p>Tamarin includes an interpreter written in Go and uses an approach called Pratt Parsing to parse expressions. The excellent book Writing an Interpreter in Go was the inspiration for the project.</p>"},{"location":"how-it-works/#the-internals","title":"The Internals","text":"<p>As with many other interpreted languages, Tamarin includes:</p> <ul> <li>A lexer which takes   source code as input and produces a stream of tokens as output.</li> <li>A parser which takes   tokens as an input and produces an abstract syntax tree (AST).</li> <li>An evaluator which   executes an AST as a program.</li> <li>Built-in types   available to all programs.</li> <li>Built-in functions   that are accesible by default.</li> </ul>"},{"location":"how-it-works/#controlling-execution","title":"Controlling Execution","text":"<p>The exec package offers a user-friendly API to use Tamarin as a library. The provided <code>context.Context</code> is used to cancel execution or limit execution with a timeout. Internally Tamarin passes this context to all operations to guarantee that execution quickly stops when the context is canceled.</p>"},{"location":"how-it-works/#concurrency","title":"Concurrency","text":"<p>A single Tamarin execution operates within a single goroutine. Multiple Tamarin executions may happen concurrently and these are entirely independent. Tamarin avoids all use of global state.</p>"},{"location":"how-it-works/#providing-input","title":"Providing Input","text":"<p>When running Tamarin as a library, you can provide input data to the scripts by passing in a scope that has been pre-populated with some variables. The scope can be passed via the <code>exec.Opts</code> struct that is passed to an execution.</p>"},{"location":"iterators/","title":"Iterators","text":"<p>You can enumerate items in any container using an iterator. Iterators are created using the <code>iter</code> built-in function or by using the <code>range</code> keyword.</p> <pre><code>&gt;&gt;&gt; my_set := {1,2,3}\n{1, 2, 3}\n&gt;&gt;&gt; iter(my_set)\nset_iter({1, 2, 3})\n</code></pre> <p>Unlike in Go, the <code>range</code> keyword is available outside of for loop definitions:</p> <pre><code>&gt;&gt;&gt; range {one: 1, two: 2}\nmap_iter({\"one\": 1, \"two\": 2})\n</code></pre> <p>Iterators offer a <code>next</code> method to retrieve the next entry in the sequence. Each entry is returned as an <code>iter_entry</code> object, which has <code>key</code> and <code>value</code> attributes. When the iterator is exhausted, <code>nil</code> is returned instead.</p> <p>For loops recognize when they're working with iterators and automatically assign each key and value to the loop variables:</p> <pre><code>&gt;&gt;&gt; s := \"abc\"\n\"abc\"\n&gt;&gt;&gt; for i, c := range s { print(\"index:\", i, \"rune:\", c) }\nindex: 0 rune: a\nindex: 1 rune: b\nindex: 2 rune: c\n</code></pre> <p>Iterators can be used directly as well:</p> <pre><code>&gt;&gt;&gt; s := \"abc\"\n\"abc\"\n&gt;&gt;&gt; iterator := iter(s)\nstring_iter(\"abc\")\n&gt;&gt;&gt; item := iterator.next()\niter_entry(0, \"a\")\n&gt;&gt;&gt; item.key\n0\n&gt;&gt;&gt; item.value\n\"a\"\n</code></pre>"},{"location":"quick-start/","title":"Quick Start","text":"<p>Here's how to get up and running with Tamarin either as a CLI or as a library.</p> <p>If this is your first time trying Tamarin, we recommend starting with the CLI.</p>"},{"location":"quick-start/#install-using-homebrew","title":"Install using Homebrew","text":"<p>Install the Tamarin CLI using Homebrew as follows:</p> <pre><code>brew tap cloudcmds/tamarin\nbrew install tamarin\n</code></pre> <p>You should then be able to run <code>tamarin -h</code> to see usage information.</p>"},{"location":"quick-start/#install-the-cli-from-source","title":"Install the CLI from Source","text":"<p>If you have Go installed on your system, you can build and install by running:</p> <pre><code>go install github.com/cloudcmds/tamarin@latest\n</code></pre> <p>The <code>tamarin</code> binary should now be present in <code>$HOME/go/bin</code> or in the location corresponding to your GOPATH directory.</p>"},{"location":"quick-start/#add-tamarin-as-a-library","title":"Add Tamarin as a Library","text":"<p>Use <code>go get</code> to add Tamarin as a library dependency of your Go project:</p> <pre><code>go get github.com/cloudcmds/tamarin@v0.0.14\n</code></pre>"},{"location":"quick-start/#run-the-repl","title":"Run the REPL","text":"<p>Running the <code>tamarin</code> command without any options will start the REPL:</p> <pre><code>$ tamarin\nTamarin\n&gt;&gt;&gt; print(\"Hello gophers!\")\nHello gophers!\n&gt;&gt;&gt;\n</code></pre> <p>Entering <code>ctrl+c</code> or <code>ctrl+d</code> will exit the program.</p>"},{"location":"quick-start/#execute-a-tamarin-string","title":"Execute a Tamarin String","text":"<p>Run <code>tamarin -c \"code-to-execute\"</code> to directly evaluate a given code string:</p> <pre><code>$ tamarin -c \"uuid.v4()\"\n\"0432500a-504a-435e-84de-16abf17b302f\"\n</code></pre>"},{"location":"quick-start/#run-a-script","title":"Run a Script","text":"<p>To run a Tamarin script in a file, pass the path to the command:</p> <pre><code>$ tamarin ./examples/pipe.tm\nGOPHERS ARE BURROWING RODENTS\n</code></pre>"},{"location":"quick-start/#vscode-extension","title":"VSCode Extension","text":"<p>VSCode users can quickly enable Tamarin syntax highlighting by installing the Tamarin VSCode Extension. A TextMate grammar file is available here that may help with syntax highlighting in other editors.</p>"},{"location":"scripts/","title":"Scripts","text":"<p>Tamarin scripts can easily be made directly executable on MacOS and Linux. In the steps below, the Tamarin script filename is <code>myscript</code>. The full path to the script is <code>/path/to/myscript</code>.</p> <p>1. Add a shebang line at the start of the Tamarin script.</p> <pre><code>#!/usr/bin/env tamarin\n</code></pre> <p>2. Allow execution as a program by running <code>chmod</code> against the script:</p> <pre><code>chmod +x /path/to/myscript\n</code></pre> <p>3. Optionally, update your <code>PATH</code> variable so that your shell can find the script:</p> <pre><code>export PATH=/path/to/:$PATH\n</code></pre> <p>Having done that, you should be able to run <code>myscript</code> as a program from your shell. You should add the <code>export PATH</code> statement to <code>~/.bashrc</code> or <code>~/.zshrc</code> to persist the modified <code>PATH</code> variable for future sessions.</p>"},{"location":"scripts/#example-script","title":"Example Script","text":"<pre><code>#!/usr/bin/env tamarin\nprint(\"just a test\")\n</code></pre>"},{"location":"syntax/","title":"Syntax","text":"<p>Tamarin was designed to be like a more scripting-friendly version of Go. At times, approaches from Python were referenced when deciding how Tamarin should approach a particular situation as an interpreted language. As a result, Tamarin may feel like a hybrid of Go and Python.</p> <p>Note</p> <p>In the examples below, when you see a <code>&gt;&gt;&gt;</code> it indicates that input and output from a Tamarin REPL session is being shown. To the right of the <code>&gt;&gt;&gt;</code> is the command the user entered. The command output is shown on the line below.</p>"},{"location":"syntax/#variables","title":"Variables","text":"<p>Variables are dynamically typed and are declared using <code>const</code>, <code>var</code>, or <code>:=</code>. After declaration, variables are updated using <code>=</code> like in Go.</p> <pre><code>x := 42             // this declares an integer\nx = \"now a string\"  // like Python, a variable may change types\nconst foo = \"bar\"   // const values cannot be updated\nvar name = \"anne\"   // this is equivalent to `name := \"anne\"`\n</code></pre> <p>Multiple variables may be assigned in one statement, where the right-hand side of the assignment is a list with a matching size:</p> <pre><code>&gt;&gt;&gt; a, b, c := [1, 2, 3]\n[1, 2, 3]\n&gt;&gt;&gt; a\n1\n&gt;&gt;&gt; b\n2\n&gt;&gt;&gt; c\n3\n</code></pre>"},{"location":"syntax/#semicolons","title":"Semicolons","text":"<p>Semicolons are optional. Multiple statements can be on a single line if separated by a semicolon.</p> <pre><code>foo := \"bar\"; baz := \"qux\"\n</code></pre>"},{"location":"syntax/#comments","title":"Comments","text":"<p>Lines are commented using <code>//</code> or <code>#</code>.</p> <pre><code>// This line is commented out\n</code></pre> <pre><code># As is this one\n</code></pre> <p>Block comments are defined using <code>/*</code> and <code>*/</code>.</p>"},{"location":"syntax/#functions","title":"Functions","text":"<p>Functions are defined using the <code>func</code> keyword and may be passed around as values. The last statement or expression in the function body is understood to be the return value, so using the <code>return</code> keyword is optional.</p> <p>The syntax for invoking a function is the same as in Go.</p> <p>Functions may be declared with default parameter values.</p> <pre><code>&gt;&gt;&gt; func increment(x, amount=1) { x + amount }\n&gt;&gt;&gt; increment(3)\n4\n&gt;&gt;&gt; increment(3, 2)\n5\n</code></pre> <p>Functions may also be assigned to variables:</p> <pre><code>const say_hello = func() {\nprint(\"hello\")\n}\nsay_hello()\n</code></pre>"},{"location":"syntax/#closures","title":"Closures","text":"<p>Closures store the environment associated with an outer function, allowing its reuse for multiple invocations of an inner function.</p> <pre><code>func get_counter(start) {\nreturn func() {\nstart++\n}\n}\nc := get_counter(5)\nprint(c()) // prints 5\nprint(c()) // prints 6\nprint(c()) // prints 7\n</code></pre>"},{"location":"syntax/#conditionals","title":"Conditionals","text":"<p>Go style conditionals are supported, including <code>if</code>, <code>else if</code>, and <code>else</code> cases. Parentheses are not required when defining the condition for each case.</p> <pre><code>if age &lt; 13 {\nprint(\"this is a kid\")\n} else if age &lt; 18 {\nprint(\"this is a young adult\")\n} else {\nprint(\"this is an adult\")\n}\n</code></pre>"},{"location":"syntax/#switch-statements","title":"Switch Statements","text":"<p>Switch statements compare a value with multiple defined cases, executing the matching case if there is one, and executing the <code>default</code> case if one exists and no other cases match.</p> <pre><code>switch name {\ncase \"ben\":\nprint(\"matched ben\")\ncase \"noa\":\nprint(\"matched noa\")\ndefault:\nprint(\"default\")\n}\n</code></pre>"},{"location":"syntax/#loops","title":"Loops","text":"<p>Multiple styles of for loops are accepted. The <code>break</code> and <code>continue</code> keywords may be used to control looping as you'd expect from other languages.</p> <p>The \"standard\" style includes init, condition, and post statements:</p> <pre><code>for i := 0; i &lt; 10; i++ {\nprint(i)\n}\n</code></pre> <p>The \"simple\" style will loop until a <code>break</code> statement is reached:</p> <pre><code>for {\nif a &gt; b {\nbreak\n}\n}\n</code></pre> <p>The \"condition-only\" style loops until the condition evaluates to <code>false</code>:</p> <pre><code>for a &lt; b {\na++\n}\n</code></pre> <p>Finally, you may also use the <code>range</code> keyword to iterate over the contents of a container:</p> <pre><code>l := [1, 2, 3]\nfor i, value := range l {\nprint(i, value)\n}\n</code></pre>"},{"location":"syntax/#pipelines","title":"Pipelines","text":"<p>Pipelines execute a series of function calls, passing each call's output as the first argument to the next call. This syntax lends itself to applying one or more transformations to input data.</p> <p>If an error is encountered at any stage in the pipeline, its execution stops early, and the error propagates as usual.</p> <p>Each expression in the pipeline is expected to evaluate to a function or method to call. Parentheses may be omitted in each call when the function accepts one argument, since that argument is passed implicitly from the previous stage. If the function accepts two or more arguments, the pipeline always provides the first argument and the code author must supply the following arguments as they would in a normal function invocation.</p> <p>This is an example of a two stage string transformation:</p> <pre><code>&gt;&gt;&gt; \"hello.\" | strings.to_upper | strings.replace_all(\".\", \"!\")\n\"HELLO!\"\n</code></pre> <p>The expression prior to the first <code>|</code> receives no special treatment in pipelines. That is, it's treated as the first argument to the subsequent function, even if it evaluates to a function value itself.</p> <p>The examples below are all equivalent and illustrate how values (which may even be a function) are passed as the first argument to the next stage.</p> <pre><code>&gt;&gt;&gt; [3, 2, 9, 5] | math.max\n9\n&gt;&gt;&gt; math.max | call([3, 2, 9, 5])\n9\n&gt;&gt;&gt; call(math.max, [3, 2, 9, 5])\n9\n</code></pre> <p>Pipelines can be used to build functions:</p> <pre><code>&gt;&gt;&gt; func normalize(s) { s | strings.fields | strings.join(\" \") }\n&gt;&gt;&gt; normalize(\"  so   much   whitespace  \")\n\"so much whitespace\"\n</code></pre>"},{"location":"syntax/#attributes","title":"Attributes","text":"<p>Objects in Tamarin may have data attributes and method attributes. Both are retrieved with a familiar <code>object.attribute</code> syntax. There is also a built-in <code>getattr</code> function that supports retrieving a named attribute from an object.</p> <p>A method accessed on an object remains bound to that object, as you can see here:</p> <pre><code>&gt;&gt;&gt; l := [1,2,3]\n[1, 2, 3]\n&gt;&gt;&gt; append := l.append\nbuiltin(list.append)\n&gt;&gt;&gt; append(4)\n[1, 2, 3, 4]\n&gt;&gt;&gt; l\n[1, 2, 3, 4]\n&gt;&gt;&gt; getattr(l, \"append\")\nbuiltin(list.append)\n</code></pre>"},{"location":"syntax/#indexing","title":"Indexing","text":"<p>Multiple Tamarin core types support index operations. These types are referred to as container types and include list, map, set, and string.</p> <p>Lists use zero-based indexing. Negative indices operate relative to the end of the list:</p> <pre><code>&gt;&gt;&gt; l := [\"a\", \"b\", \"c\"]\n[\"a\", \"b\", \"c\"]\n&gt;&gt;&gt; l[2]\n\"c\"\n&gt;&gt;&gt; l[-1]\n\"c\"\n</code></pre> <p>Map indexing is used to retrieve the value for a given key:</p> <pre><code>&gt;&gt;&gt; m := {name:\"evan\", age:18}\n{\"age\": 18, \"name\": \"evan\"}\n&gt;&gt;&gt; m[\"name\"]\n\"evan\"\n</code></pre> <p>Set indexing is used to check whether a value is present in the set:</p> <pre><code>&gt;&gt;&gt; s := {3,4,5}\n{3, 4, 5}\n&gt;&gt;&gt; s[5]\ntrue\n&gt;&gt;&gt; s[6]\nfalse\n</code></pre> <p>String indexing is used to read unicode code points, known as runes in Go, from a given string. Note this behavior differs from Go string indexing, which operates on the underlying bytes.</p> <pre><code>&gt;&gt;&gt; const s = \"\u6b63\u9ad4\u5b57\"\n\"\u6b63\u9ad4\u5b57\"\n&gt;&gt;&gt; s[0]\n\"\u6b63\"\n&gt;&gt;&gt; s[1]\n\"\u9ad4\"\n</code></pre>"},{"location":"syntax/#slices","title":"Slices","text":"<p>Lists and strings in Tamarin support slice operations to select a range of items.</p> <pre><code>&gt;&gt;&gt; l := [\"a\", \"b\", \"c\"]\n[\"a\", \"b\", \"c\"]\n&gt;&gt;&gt; l[0:2]\n[\"a\", \"b\"]\n&gt;&gt;&gt; l[-2:]\n[\"b\", \"c\"]\n</code></pre> <p>The syntax for this is <code>l[start:stop]</code> where <code>start</code> and <code>stop</code> may be omitted in order to refer to the beginning or the end of the sequence, respectively.</p>"},{"location":"syntax/#import","title":"Import","text":"<p>Tamarin files may be imported as modules using the <code>import</code> keyword. All module data and functions are available as attributes on the module after import. As a convention, if an attribute is intended to be private to a module, prefix its name with an underscore.</p> <pre><code>&gt;&gt;&gt; import library\nmodule(library.tm)\n&gt;&gt;&gt; library.add(2,3)\n5\n</code></pre>"},{"location":"syntax/#the-in-keyword","title":"The in Keyword","text":"<p>Check if an item exists is a container using the <code>in</code> keyword:</p> <pre><code>&gt;&gt;&gt; 42 in [40, 41, 42]\ntrue\n&gt;&gt;&gt; 3 in {2,3,4}\ntrue\n&gt;&gt;&gt; \"foo\" in {foo: \"bar\"}\ntrue\n&gt;&gt;&gt; \"foo\" in \"bar foo baz\"\ntrue\n</code></pre>"},{"location":"using-go-structs/","title":"Using go structs","text":""},{"location":"using-go-structs/#proxying-calls-to-go-objects","title":"Proxying Calls to Go Objects","text":"<p>You can expose arbitrary Go objects to Tamarin code in order to enable method calls on those objects. This allows you to expose existing structs in your application as Tamarin objects that scripts can be written against. Tamarin automatically discovers public methods on your Go types and converts inputs and outputs for primitive types and for structs that you register.</p> <p>Input and output values are type-converted automatically, for a variety of types. Go structs are mapped to Tamarin map objects. Go <code>context.Context</code> and <code>error</code> values are handled automatically.</p> proxy_service.go<pre><code>    // Create a registry that tracks proxied Go types and their attributes\nregistry, err := object.NewTypeRegistry()\nif err != nil {\nreturn err\n}\n// This is the Go service we will expose in Tamarin\nsvc := &amp;MyService{}\n// Wrap the service in a Tamarin Proxy\nproxy, err := object.NewProxy(registry, svc)\nif err != nil {\nreturn err\n}\n// Add the proxy to a Tamarin execution scope\ns := scope.New(scope.Opts{})\ns.Declare(\"svc\", proxy, true)\n// Execute Tamarin code against that scope. By doing this, the Tamarin\n// code can call public methods on `svc` and retrieve its public fields.\nresult, err := exec.Execute(ctx, exec.Opts{\nInput: string(scriptSourceCode),\nScope: s,\n})\n</code></pre> <p>See example-proxy for a complete example.</p>"}]}